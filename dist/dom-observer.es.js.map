{"version":3,"file":"dom-observer.es.js","sources":["../src/DomParser.ts","../src/EventEmitter.ts","../src/DomObserver.ts","../src/DomCollector.ts"],"sourcesContent":["/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\ntype ParserConfigObject = {\n    type: \"object\"\n    keys: {\n        key: string\n        value: ParserConfig\n    }[]\n}\n\ntype ParserConfigArray = {\n    type: \"array\"\n    selector: string\n    items?: ParserConfig\n}\n\ntype ParserConfigString = {\n    type: \"string\"\n    selector: string\n}\n\ntype ParseConfigBoolean = {\n    type: \"boolean\"\n    selector: string\n}\n\ntype ParseConfigNumber = {\n    type: \"number\"\n    selector: string\n    formatter: (value: string | null, el: HTMLElement | null) => number | null\n}\n\nexport type ParserConfig =\n    | ParserConfigObject\n    | ParserConfigArray\n    | ParserConfigString\n    | ParseConfigBoolean\n    | ParseConfigNumber\n\nexport type ParseDomResult =\n    | string\n    | null\n    | boolean\n    | number\n    | Array<ParseDomResult>\n    | {\n          [key: string]: ParseDomResult\n      }\n\n/**\n * Parse a specific structure from the DOM recursively\n * @param  config - configuration object that describes the type of the resulting object and how to get it from the DOM\n * @param  rootElement - root DOM element. will be parsed inside the children of this element\n * @return result of parsing\n */\nexport function parseDOM(\n    config: ParserConfig,\n    rootElement?: HTMLElement\n): ParseDomResult {\n    if (config.type === \"string\") {\n        const parentElement = rootElement || window.document\n        const targetElement = parentElement.querySelector<HTMLElement>(\n            config.selector\n        )\n        return targetElement ? targetElement.textContent : null\n    }\n    if (config.type === \"number\") {\n        const parentElement = rootElement || window.document\n        const targetElement = parentElement.querySelector<HTMLElement>(\n            config.selector\n        )\n        const value = targetElement ? targetElement.textContent : null\n        return config.formatter(value, targetElement)\n    }\n\n    if (config.type === \"boolean\") {\n        const parentElement = rootElement || window.document\n        const targetElement = parentElement.querySelector<HTMLElement>(\n            config.selector\n        )\n        return Boolean(targetElement)\n    }\n    if (config.type === \"array\") {\n        const mathedElems = document.querySelectorAll<HTMLElement>(\n            config.selector\n        )\n        if (config.items) {\n            const values = [] as ParseDomResult[]\n            for (const el of mathedElems) {\n                values.push(parseDOM(config.items, el))\n            }\n            return values\n        } else {\n            return [...mathedElems].map((el: HTMLElement) => el.textContent)\n        }\n    }\n    if (config.type === \"object\") {\n        const result = {} as { [key: string]: ParseDomResult }\n        for (const { key, value } of config.keys) {\n            result[key] = parseDOM(value, rootElement)\n        }\n        return result\n    }\n    return null\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\ntype EventHadler<P = any> = (p: P) => any\n\ntype Event = {\n    eventName: string\n    handlers: EventHadler[]\n}\n\n/* Simple EventEmitter */\nexport class EventEmitter {\n    private events: Event[] = []\n\n    private createUnwatcher<P = any>(\n        eventName: string,\n        handler: EventHadler<P>\n    ) {\n        return () => {\n            for (let i = 0; i < this.events.length; i++) {\n                const event = this.events[i]\n                event.handlers = event.handlers.filter(\n                    existingHandler => existingHandler !== handler\n                )\n                if (event.handlers.length) continue\n                this.events.splice(i, 1)\n                i--\n            }\n        }\n    }\n\n    public on<P = any>(eventName: string, handler: EventHadler<P>) {\n        const unwatch = this.createUnwatcher<P>(eventName, handler)\n\n        const existingEvent = this.events.find(\n            found => found.eventName === eventName\n        )\n        if (existingEvent && existingEvent.handlers.includes(handler)) {\n            return unwatch\n        } else if (existingEvent) {\n            existingEvent.handlers.push(handler)\n        } else {\n            this.events.push({ eventName, handlers: [handler] })\n        }\n        return unwatch\n    }\n\n    public off<P = any>(eventName: string, handler: EventHadler<P>) {\n        const unwatch = this.createUnwatcher(eventName, handler)\n        unwatch()\n    }\n\n    public dispatch<P = any>(eventName: string, payload?: P) {\n        const event = this.events.find(event => event.eventName === eventName)\n        if (event) {\n            for (const handler of event.handlers) {\n                handler(payload)\n            }\n        }\n    }\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\nimport { EventEmitter } from \"./EventEmitter\"\n\nconst MAIN_OBSERVER_CONFIG = {\n    attributes: false,\n    childList: true,\n    subtree: true,\n    characterData: false,\n    characterDataOldValue: false,\n    attributeOldValue: false,\n}\n\ntype TargetElementDescriptor = {\n    name: string\n    selector: string\n    observerConfig?: MutationObserverInit\n}\n\ntype TargetElementsObserver = {\n    descriptor: TargetElementDescriptor\n    observers: MutationObserver[]\n}\n\nexport const FOUND_EVENT_NAME = \"target-element-found\"\nexport const MUTATED_EVENT_NAME = \"target-element-mutated\"\n\nexport type FoundEvent = {\n    type: typeof FOUND_EVENT_NAME\n    descriptor: TargetElementDescriptor\n    element: HTMLElement\n}\n\nexport type MutatedEvent = {\n    type: typeof MUTATED_EVENT_NAME\n    descriptor: TargetElementDescriptor\n    mutations: MutationRecord[]\n}\n\nexport type ObserveDomEvent = FoundEvent | MutatedEvent\n\nexport type MainObserverCb = (mutations: MutationRecord[]) => void\n\ntype SubscribeCb = (e: ObserveDomEvent) => void\n\nexport class DomObserver extends EventEmitter {\n    private _mainObserver: MutationObserver | null = null\n    private _observedElements: HTMLElement[] = []\n    private _targetElementsObservers: TargetElementsObserver[] = []\n    private _targetElementsDescriptors: TargetElementDescriptor[] = []\n    private _checkTargetSelectorAndObserve(\n        descriptor: TargetElementDescriptor,\n        el: HTMLElement,\n        mutationsList: MutationRecord[],\n    ) {\n        const targetElements = el.matches(descriptor.selector)\n            ? [el]\n            : [...el.querySelectorAll<HTMLElement>(descriptor.selector)]\n\n        if (!targetElements.length) {\n            return\n        }\n\n        this._observeTargetElements(targetElements, descriptor)\n\n        // check if the mutation of the target node is in the mutations list\n        const matchedMutations = this._matchTargetElementMutations(\n            descriptor,\n            mutationsList\n        )\n        if (matchedMutations.length) {\n            this._dispatchMutatedEvent(matchedMutations, descriptor)\n        }\n    }\n    private _matchTargetElementMutations(\n        descriptor: TargetElementDescriptor,\n        mutationsList: MutationRecord[]\n    ) {\n        const matchedMutations = []\n        for (const mutation of mutationsList) {\n            if ((mutation.target as HTMLElement).closest(descriptor.selector)) {\n                matchedMutations.push(mutation)\n            }\n        }\n        return matchedMutations\n    }\n    private _observeTargetElements(\n        elems: HTMLElement[],\n        descriptor: TargetElementDescriptor\n    ) {\n        const observer = new window.MutationObserver(mutations =>\n            this._onTargetElementMutated(mutations, descriptor)\n        )\n        for (const elem of elems) {\n            // already observed\n            if (this._observedElements.includes(elem)) continue\n            this._observedElements.push(elem)\n            const html = elem.innerHTML\n            this._dispatchFoundEvent(descriptor, elem)\n            observer.observe(elem, descriptor.observerConfig)\n        }\n        const existingObserverItem = this._targetElementsObservers.find(\n            found => found.descriptor.name === descriptor.name\n        )\n        if (existingObserverItem) {\n            existingObserverItem.observers.push(observer)\n        } else {\n            this._targetElementsObservers.push({\n                descriptor,\n                observers: [observer],\n            })\n        }\n    }\n    private _onTargetElementMutated(\n        mutations: MutationRecord[],\n        descriptor: TargetElementDescriptor\n    ) {\n        this._dispatchMutatedEvent(mutations, descriptor)\n    }\n    private _dispatchMutatedEvent(\n        mutations: MutationRecord[],\n        descriptor: TargetElementDescriptor\n    ) {\n        const payload: MutatedEvent = {\n            type: MUTATED_EVENT_NAME,\n            descriptor,\n            mutations,\n        }\n        this.dispatch(\"target-element-mutated\", payload)\n    }\n    private _dispatchFoundEvent(\n        descriptor: TargetElementDescriptor,\n        element: HTMLElement\n    ) {\n        const payload: FoundEvent = {\n            type: FOUND_EVENT_NAME,\n            descriptor,\n            element,\n        }\n        this.dispatch(\"target-element-found\", payload)\n    }\n    private _onRootElementMutated = (mutationsList: MutationRecord[]) => {\n        for (const mutation of mutationsList) {\n            if (mutation.type !== \"childList\") continue\n            for (const node of mutation.addedNodes) {\n                if (!(node instanceof window.HTMLElement)) continue\n                for (const descriptor of this._targetElementsDescriptors) {\n                    this._checkTargetSelectorAndObserve(\n                        descriptor,\n                        node,\n                        mutationsList\n                    )\n                }\n            }\n\n            this._clearObservedElementsByMutation(mutation)\n        }\n    }\n    private _clearObservedElementsByMutation(mutation: MutationRecord) {\n        this._observedElements = this._observedElements.filter(\n            (obvservedNode) => {\n                return ![...mutation.removedNodes].includes(obvservedNode)\n            }\n        )\n    }\n    private _clearObservedElementsByDescriptor(\n        descriptor: TargetElementDescriptor\n    ) {\n        this._observedElements = this._observedElements.filter(\n            (observedNode) => {\n                return !observedNode.matches(descriptor.selector)\n            }\n        )\n    }\n    constructor(private _rootElement: HTMLElement = document.body) {\n        super()\n    }\n    get observedElements() {\n        return [...this._observedElements]\n    }\n    public start(cb?: MainObserverCb) {\n        this._mainObserver = new window.MutationObserver(mutations => {\n            this._onRootElementMutated(mutations)\n            if (cb) {\n                cb(mutations)\n            }\n        })\n        this._mainObserver.observe(this._rootElement, MAIN_OBSERVER_CONFIG)\n        return this\n    }\n    public stop() {\n        if (this._mainObserver) {\n            this._mainObserver.disconnect()\n            this._onRootElementMutated(this._mainObserver.takeRecords())\n            this._mainObserver = null\n        }\n        this.stopObservation()\n        return this\n    }\n    public subscribe(cb: SubscribeCb, descriptor?: TargetElementDescriptor) {\n        const handleEvent = (e: ObserveDomEvent) => {\n            if (!descriptor) {\n                cb(e)\n                return\n            }\n            if (descriptor.name === e.descriptor.name) {\n                cb(e)\n            }\n        }\n        this.on<MutatedEvent>(MUTATED_EVENT_NAME, handleEvent)\n        this.on<FoundEvent>(FOUND_EVENT_NAME, handleEvent)\n        return () => {\n            this.off(MUTATED_EVENT_NAME, handleEvent)\n            this.off(FOUND_EVENT_NAME, handleEvent)\n        }\n    }\n    public stopObservation(name?: string) {\n        for (let i = 0; i < this._targetElementsObservers.length; i++) {\n            const targetElementObserver = this._targetElementsObservers[i]\n            if (name && targetElementObserver.descriptor.name !== name) continue\n\n            this._clearObservedElementsByDescriptor(\n                targetElementObserver.descriptor\n            )\n\n            for (const mObserver of targetElementObserver.observers) {\n                const unhandledRecords = mObserver.takeRecords()\n                if (unhandledRecords.length) {\n                    this._onTargetElementMutated(\n                        unhandledRecords,\n                        targetElementObserver.descriptor\n                    )\n                }\n                mObserver.disconnect()\n            }\n            this._targetElementsObservers.splice(i, 1)\n            i--\n        }\n        if (!name) {\n            this._targetElementsDescriptors = []\n            return this\n        }\n        const updatedDescriptors = this._targetElementsDescriptors.filter(\n            found => found.name !== name\n        )\n        this._targetElementsDescriptors = updatedDescriptors\n        return this\n    }\n    public observe(descriptor: TargetElementDescriptor) {\n        this._targetElementsDescriptors.push(descriptor)\n        // element already exists\n        const targetElements = [\n            ...this._rootElement.querySelectorAll<HTMLElement>(\n                descriptor.selector\n            ),\n        ]\n        if (targetElements.length) {\n            this._observeTargetElements(targetElements, descriptor)\n        }\n        return this\n    }\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\nimport { DomObserver, MainObserverCb } from \"./DomObserver\"\nimport { parseDOM, ParserConfig } from \"./DomParser\"\n\nexport type DomCollectorTarget = {\n    name: string\n    targetSelector: string\n    guardSelector?: string\n    parseRootEl: string | HTMLElement\n    observeConfig?: MutationObserverInit\n    parseConfig: ParserConfig\n}\n\ntype DomCollectorResult = {\n    name: string\n    parsedContent: any\n}\n\ntype Params = {\n    targets: DomCollectorTarget[]\n    onCollect: (result: DomCollectorResult) => void\n    rootEl?: HTMLElement\n    mainObserverCallback?: MainObserverCb\n}\n\nconst DEFAULT_OBSERVER_CONFIG = {\n    attributes: false,\n    childList: true,\n    subtree: true,\n    characterData: false,\n    characterDataOldValue: false,\n    attributeOldValue: false,\n}\n\nexport const createDomCollector = ({\n    targets,\n    onCollect,\n    rootEl,\n    mainObserverCallback,\n}: Params) => {\n    const domObserver = new DomObserver(rootEl || document.body)\n    domObserver.start(mainObserverCallback)\n\n    for (const target of targets) {\n        const observeDescriptor = {\n            name: target.name,\n            selector: target.targetSelector,\n            observerConfig: target.observeConfig || DEFAULT_OBSERVER_CONFIG,\n        }\n        domObserver.subscribe((e) => {\n            const { guardSelector } = target\n            if (!guardSelector || document.querySelector(guardSelector)) {\n                const parseRootEl =\n                    typeof target.parseRootEl === \"string\"\n                        ? document.querySelector<HTMLElement>(\n                            target.parseRootEl\n                        )\n                        : target.parseRootEl\n                if (!parseRootEl) {\n                    return\n                }\n                const parsedContent = parseDOM(target.parseConfig, parseRootEl)\n                onCollect({\n                    name: target.name,\n                    parsedContent,\n                })\n            }\n        }, observeDescriptor)\n        domObserver.observe(observeDescriptor)\n    }\n\n    return domObserver\n}\n"],"names":["parseDOM","config","rootElement","type","targetElement","window","document","querySelector","selector","textContent","value","formatter","Boolean","mathedElems","querySelectorAll","items","values","el","push","map","result","key","keys","EventEmitter","[object Object]","this","eventName","handler","i","events","length","event","handlers","filter","existingHandler","splice","unwatch","createUnwatcher","existingEvent","find","found","includes","payload","MAIN_OBSERVER_CONFIG","attributes","childList","subtree","characterData","characterDataOldValue","attributeOldValue","FOUND_EVENT_NAME","MUTATED_EVENT_NAME","DomObserver","_rootElement","body","super","mutationsList","mutation","node","addedNodes","HTMLElement","descriptor","_targetElementsDescriptors","_checkTargetSelectorAndObserve","_clearObservedElementsByMutation","targetElements","matches","_observeTargetElements","matchedMutations","_matchTargetElementMutations","_dispatchMutatedEvent","target","closest","elems","observer","MutationObserver","mutations","_onTargetElementMutated","elem","_observedElements","innerHTML","_dispatchFoundEvent","observe","observerConfig","existingObserverItem","_targetElementsObservers","name","observers","dispatch","element","obvservedNode","removedNodes","observedNode","observedElements","cb","_mainObserver","_onRootElementMutated","disconnect","takeRecords","stopObservation","handleEvent","e","on","off","targetElementObserver","_clearObservedElementsByDescriptor","mObserver","unhandledRecords","updatedDescriptors","DEFAULT_OBSERVER_CONFIG","createDomCollector","targets","onCollect","rootEl","mainObserverCallback","domObserver","start","observeDescriptor","targetSelector","observeConfig","subscribe","guardSelector","parseRootEl","parsedContent","parseConfig"],"mappings":"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"}